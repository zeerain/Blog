(window.webpackJsonp=window.webpackJsonp||[]).push([[29],{226:function(_,v,t){"use strict";t.r(v);var e=t(0),o=Object(e.a)({},(function(){var _=this,v=_.$createElement,t=_._self._c||v;return t("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[t("h2",{attrs:{id:"原型"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#原型"}},[_._v("#")]),_._v(" 原型")]),_._v(" "),t("ol",[t("li",[_._v("概念：所谓原型就是指函数的 "),t("code",[_._v("prototype")]),_._v(" 属性所引用的对象\n"),t("ul",[t("li",[_._v("只要定义一个函数，那么就会创建其原型")]),_._v(" "),t("li",[_._v("由上述函数创建出来的所有对象，都可以直接访问到原型上的成员")])])]),_._v(" "),t("li",[_._v("作用：实现同类对象之间的数据共享。")]),_._v(" "),t("li",[_._v("获取原型方式\n"),t("ul",[t("li",[_._v("通过函数："),t("code",[_._v("fnName.prototype")])]),_._v(" "),t("li",[_._v("通过对象："),t("code",[_._v("objName.__proto__")])]),_._v(" "),t("li",[_._v("注意：以 "),t("code",[_._v("__")]),_._v(" 开头和结尾的属性均为非标准属性，原型默认具有 "),t("code",[_._v("constructor")]),_._v(" 属性，引用的就是其构造函数")])])])]),_._v(" "),t("h2",{attrs:{id:"原型特性"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#原型特性"}},[_._v("#")]),_._v(" 原型特性")]),_._v(" "),t("blockquote",[t("p",[_._v("动态性：置换原型记得重新要设置 constructor 属性指向构造函数！！！")])]),_._v(" "),t("ul",[t("li",[_._v("动态性\n"),t("ul",[t("li",[_._v("在已有的原型上扩展成员，直接反映到已创建出来的对象上")]),_._v(" "),t("li",[_._v("如果置换了已有的原型，那么会反映到后面新创建的对象，而不会影响之前创建的对象")])])]),_._v(" "),t("li",[_._v("唯一性\n"),t("ul",[t("li",[_._v("由同一个构造函数创建出来的所有对象，都共享一个原型")])])]),_._v(" "),t("li",[_._v("不可变性(对于基本类型的属性)\n"),t("ul",[t("li",[_._v("不能通过对象来修改原型上的成员（仅对基本类型属性而言）")])])]),_._v(" "),t("li",[_._v("共享性\n"),t("ul",[t("li",[_._v("所有的对象都可以直接访问其原型上的成员")])])])]),_._v(" "),t("h3",{attrs:{id:"组合方式创建对象"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#组合方式创建对象"}},[_._v("#")]),_._v(" 组合方式创建对象")]),_._v(" "),t("ul",[t("li",[_._v("组合原型和构造函数一起来创建对象")]),_._v(" "),t("li",[_._v("将私有的属性写在构造函数内")]),_._v(" "),t("li",[_._v("将共有的属性或行为写到其原型上")])]),_._v(" "),t("h3",{attrs:{id:"proto-与-prototype"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#proto-与-prototype"}},[_._v("#")]),_._v(" "),t("code",[_._v("__proto__")]),_._v(" 与 prototype")]),_._v(" "),t("ol",[t("li",[t("p",[_._v("函数（方法）拥有自己特有的属性 -- 原型属性 (prototype)，这个属性是一个指针，指向一个对象，这个对象的用途就是包含所有实例共享的属性和方法（这个对象叫做"),t("strong",[_._v("原型对象")]),_._v("）。原型对象也有一个属性，叫做 constructor，这个属性包含了一个指针，指回原构造函数。")])]),_._v(" "),t("li",[t("p",[_._v("在 js 中，万物皆对象。方法 (Function) 是对象，方法的原型 (Function.prototype) 是对象。因此，他们都会具有对象共有的特点。即对象具有属性 "),t("code",[_._v("__proto__")]),_._v("，可称为隐式原型。一个对象的隐式原型指向构造该对象的构造函数的原型，这也保证了实例能够访问在构造函数原型中定义的属性和方法。")])])]),_._v(" "),t("h2",{attrs:{id:"继承"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#继承"}},[_._v("#")]),_._v(" 继承")]),_._v(" "),t("ol",[t("li",[t("p",[_._v("注意：其他面向对象语言 C# Java swift 类与类之间继承，而在js中，是对象与对象之间的继承")])]),_._v(" "),t("li",[t("p",[_._v("概念：就是指 一个对象有权去访问另一个对象上的成员（属性和方法）")])]),_._v(" "),t("li",[t("p",[_._v("继承的实现")]),_._v(" "),t("ul",[t("li",[_._v("原型式继承\n"),t("ol",[t("li",[_._v("在原有的原型上扩展")]),_._v(" "),t("li",[_._v("置换原型")])])]),_._v(" "),t("li",[_._v("混入式：将要继承的对象上的所有成员拷贝一份，添加到本身。")])])]),_._v(" "),t("li",[t("p",[_._v("Object.create方法")]),_._v(" "),t("ul",[t("li",[_._v("实现原型式继承（通过置换原型方法）")]),_._v(" "),t("li",[_._v("语法：")])]),_._v(" "),t("div",{staticClass:"language-javascript line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-javascript"}},[t("code",[t("span",{pre:!0,attrs:{class:"token keyword"}},[_._v("var")]),_._v(" newObj "),t("span",{pre:!0,attrs:{class:"token operator"}},[_._v("=")]),_._v(" Object"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[_._v("create")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v("(")]),_._v("parent"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(";")]),_._v("\n")])]),_._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[_._v("1")]),t("br")])])]),_._v(" "),t("li",[t("p",[_._v("相关结论：")]),_._v(" "),t("ul",[t("li",[t("code",[_._v("Object.prototype")]),_._v(" 的原型为 "),t("code",[_._v("null")])]),_._v(" "),t("li",[_._v("默认原型对象的原型为 "),t("code",[_._v("Object.prototype")])])])]),_._v(" "),t("li",[t("p",[_._v("属性搜索原则：当访问对象的某个属性时，")]),_._v(" "),t("ul",[t("li",[_._v("首先，在对象本身上查找，如果找到就返回值，并停止查找")]),_._v(" "),t("li",[_._v("如果没有找到就向其原型对象上查找，如果找到就返回值，并停止查找；")]),_._v(" "),t("li",[_._v("如果在没有找到，就继续向其原型的原型对象上查找，直到 "),t("code",[_._v("Object.prototype")])]),_._v(" "),t("li",[_._v("此时如果找到就返回值，否则值为 "),t("code",[_._v("undefined")])])])])]),_._v(" "),t("h2",{attrs:{id:"原型链的概念"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#原型链的概念"}},[_._v("#")]),_._v(" 原型链的概念")]),_._v(" "),t("ul",[t("li",[_._v("所谓原型链 就是指从一个对象到 "),t("code",[_._v("Object.prototype")]),_._v(" 之间存在一条体现继承层次关系的链式结构，这个结构被称为对象的原型链。")]),_._v(" "),t("li",[_._v("本质：链上的每一个对象都是通过 "),t("code",[_._v("__proto__")]),_._v(" 属性连接起来的。")])]),_._v(" "),t("h3",{attrs:{id:"绘制原型链"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#绘制原型链"}},[_._v("#")]),_._v(" 绘制原型链")]),_._v(" "),t("ul",[t("li",[_._v("先简写对象的原型链")]),_._v(" "),t("li",[_._v("将上述原型链上的所有对象绘制在图形上。并且将和原型链相关的属性添加到对象上")]),_._v(" "),t("li",[_._v("给对象的每一个属性确定指向")]),_._v(" "),t("li",[_._v("如果在图形上的每一个对象的属性都有正确指向，说明绘制完成")])]),_._v(" "),t("h3",{attrs:{id:"object-prototype-的方法简介"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#object-prototype-的方法简介"}},[_._v("#")]),_._v(" Object.prototype 的方法简介")]),_._v(" "),t("ol",[t("li",[t("p",[_._v("hasOwnProperty")]),_._v(" "),t("ul",[t("li",[_._v("has 有")]),_._v(" "),t("li",[_._v("own 自己的")]),_._v(" "),t("li",[_._v("property 属性")]),_._v(" "),t("li",[_._v('语法：obj.hasOwnProperty("propName")')]),_._v(" "),t("li",[_._v("用来判断指定属性是否为对象自身的，而不是继承过来的;如果是自身的就返回 true，否则返回 false")])])]),_._v(" "),t("li",[t("p",[_._v("isPrototypeOf")]),_._v(" "),t("ul",[t("li",[_._v("is 是")]),_._v(" "),t("li",[_._v("Prototype 原型")]),_._v(" "),t("li",[_._v("of 的")]),_._v(" "),t("li",[_._v("obj1.isPrototypeOf(obj2)")]),_._v(" "),t("li",[_._v("用来判断 obj1 对象是否为 obj2 对象的原型；如果是，就返回 true，否则返回 false")])])]),_._v(" "),t("li",[t("p",[_._v("propertyIsEnumerable")]),_._v(" "),t("ul",[t("li",[_._v("property 属性")]),_._v(" "),t("li",[_._v("is 是")]),_._v(" "),t("li",[_._v("Enumerable 可枚举的，可以使用 "),t("code",[_._v("for in")]),_._v(" 遍历出来的属性")]),_._v(" "),t("li",[_._v("obj.propertyIsEnumerable('propName')")]),_._v(" "),t("li",[_._v("hasOwnProperty 升级版：")]),_._v(" "),t("li",[_._v("满足这2个条件返回 true，否则返回 false\n"),t("ul",[t("li",[_._v("指定的属性必须是对象本身的")]),_._v(" "),t("li",[_._v("该属性必须可枚举")])])])])])]),_._v(" "),t("h2",{attrs:{id:"装箱-与-拆箱"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#装箱-与-拆箱"}},[_._v("#")]),_._v(" 装箱 与 拆箱")]),_._v(" "),t("ul",[t("li",[_._v("将基本数据类型 转换为 复合数据类型，这个过程被称为 装箱")]),_._v(" "),t("li",[_._v("将复合数据类型 转换为 基本数据类型，这个过程被称为 拆箱")])]),_._v(" "),t("h2",{attrs:{id:"强调几点"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#强调几点"}},[_._v("#")]),_._v(" 强调几点")]),_._v(" "),t("ul",[t("li",[_._v("默认原型对象才具有 "),t("code",[_._v("constructor")]),_._v(" 属性 (置换原型之后需要手动添加 "),t("code",[_._v("constructor")]),_._v(" 属性)")]),_._v(" "),t("li",[_._v("只有函数具有 "),t("code",[_._v("prototype")]),_._v(" 属性（除了 "),t("code",[_._v("Function.prototype")]),_._v(" ）")]),_._v(" "),t("li",[_._v("任意的对象都具有 "),t("code",[_._v("__proto__")]),_._v(" 属性")])]),_._v(" "),t("h2",{attrs:{id:"instanceof介绍"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#instanceof介绍"}},[_._v("#")]),_._v(" instanceof介绍")]),_._v(" "),t("ul",[t("li",[t("p",[_._v("obj instanceof constructor（构造函数）")])]),_._v(" "),t("li",[t("p",[_._v("规则：如果 constructor 的原型 出现在 obj 的原型链上的话，表达式返回值为 true，否则 false")])])])])}),[],!1,null,null,null);v.default=o.exports}}]);